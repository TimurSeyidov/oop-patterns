# ПРИНЦИПЫ SOLID
***
## Автор:

Хасанов Радмир Ринатович
***
### Принцип единственной ответственности
Принцип единой ответственности гласит, что у каждого класса должна быть только одна «ответственность» и он не должен брать на себя другие обязанности. Роберт К. Мартин объяснял его так: «У класса должна быть лишь одна причина для изменения». 
# Пример:
```
class User:
    def __init__(self, name: str):
            self.name = name
    
    def get_name(self):
        pass


class Storage:
    def save(self, user: User):
        ...


class HttpConnection:
	def send(self, user: User):
		...


class Logger:
	def log(self, user: User):
		... 
   ```
        
   Мы создали отдельные классы, которые возьмут на себя одну ответственность.  Размеры отдельных сущностей стали меньше, следовательно, их легче читать и с ними легче работать. Появилась возможность дать задачи нескольким разработчикам изменять разные компоненты одновременно, и никаких конфликтов возникать не должно.
***
### Принцип открытости/закрытости

Принцип открытости/закрытости впервые был сформулирован Бернардом Мейером в 1988 году. Роберт К. Мартин говорил о нем так «Наиболее важный принцип открытости/закрытости гласит «Сущности программы (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменений».

Следование этому принципу гарантирует, что класс определен достаточно, чтобы делать то, что он должен делать. Добавление любых дополнительных функций может быть реализовано путем создания новых сущностей, которые расширяют возможности существующего класса и добавляют дополнительные функции самим себе. Таким образом можно предотвратить частые и тривиальные изменения в хорошо зарекомендовавшем себя классе низкого уровня.   
Допустим, у нас есть приложение для магазина одежды. Среди функций системы есть функция применения специальных скидок в зависимости от типа одежды. 
# Пример:
```
class Attacker:
	"""Интерфейс для атакующих классов."""
    def attack(): raise NotImplementedError


class Weapon(Attacker):
	"""Задает общую структуру орудий."""
    def __init__(self, name: str, damage: int):
        self.name = name
        self.damage = damage


class Sword(Weapon):
	"""
	Наследует структуру орудия и реализует интерфейс для атаки.
	"""
    def attack(self):
        print(f"{self.name} наносит удар: -{self.damage} hp")


class Bow(Weapon):
    def attack(self):
        print(f"{self.name} стреляет: -{self.damage} hp")


sword = Sword("Needle", 24, 3)
bow = Bow("Twig", 30, 100)

aria = Character("Aria", sword)
aria.attack() # Output: Needle наносит удар: -24 hp

aria.change_weapon(bow)
aria.attack() # Output: Twig стреляет: -30 hp
```

***
  ### Принцип подстановки Барбары Лисков
  Принцип подстановки Лисков был одним из самых сложных принципов для меня, и чтобы понять его правильно, мне пришлось посмотреть различные примеры в Интернете. Я считаю, что после осознания, этот принцип станет одним из самых простых, среди принципов, которых следует придерживаться при разработке объектно-ориентированных приложений.

Принцип подстановки Лисков гласит: «Объекты в программе должны быть заменяемы экземплярами их подтипов без ущерба корректности работы программы».
# Пример:
```
from dataclasses import dataclass


@dataclass
class Position:
	x: int = 0
	y: int = 0

	def __str__(self):
		return f"({self.x}, {self.y})"


class Character:
	"""Суперкласс персонажей."""
	def __init__(self, name: str):
		self.name = name
		self.position = Position()

	def move(self, destination: Position):
		print("{name} двигается с {start} на {end}".format(
			name=self.name, start=self.position, end=destination
		))
		self.position = destination


class Human(Character):
	"""Дочерний класс, соблюдающий логику родителя."""
	def move(self, destination: Position):
		print("{name} идёт с {start} на {end}".format(
			name=self.name, start=self.position, end=destination
		))
		self.position = destination

	def buy(self):
		"""Добавляет свою логику."""
		print("Купить предмет.")


class Dragon(Character):
	"""Дочерний класс, соблюдающий логику родителя."""
	def move(self, destination: Position):
		print("{name} летит с {start} на {end}".format(
			name=self.name, start=self.position, end=destination
		))
		self.position = destination

	def attack(self):
		"""Добавляет свою логику."""
		print("Извернуть пламя на противника.")


def move(character: Character, destination: Position):
    """
    Клиент, который использует `Character` и его потомков,
    не замечая разницы.
    """
    character.move(destination)


spirit = Character("Spirit")
john = Human("John")
drogon = Dragon("Drogon")

meeting_point = Position(x=300, y=250)

move(spirit, meeting_point)
move(john, meeting_point)
move(drogon, meeting_point)
```
LSP это основа хорошего объектно-ориентированного проектирования программного обеспечения, потому что он следует одному из базовых принципов ООП — полиморфизму. Речь о том, чтобы создавать правильные иерархии такие, что классы, производные от базового являлись полиморфными для их родителя по отношению к методам его интерфейсов. Ещё интересно отметить, как этот принцип относится к примеру предыдущего принципа. Если мы пытаемся расширить класс новым несовместимым классом, то все сломается. Взаимодействие с клиентом будет нарушено, и как результат, такое расширение будет невозможно (или, для того чтобы сделать это возможным, нам пришлось бы нарушить другой принцип и модифицировать код клиента, который должен быть закрыт для модификации, такое крайне нежелательно и неприемлемо).
  ***
  ### Принцип разделения интерфейсов
  Принцип разделения интерфейсов гласит, что «Ни один клиент не должен зависеть от методов, которые он не использует». 

Принцип разделения интерфейсов был предложен Робертом К. Мартином, когда он консультировал компанию Xerox.

Принцип разделения интерфейсов предполагает создание небольших интерфейсов, известных как «ролевые интерфейсы», вместо большого интерфейса, состоящего из нескольких методов. Разделяя методы по ролям на более мелкие интерфейсы, клиенты будут зависеть только от методов, которые имеют к ним отношение.

Допустим, мы разрабатываем приложение для различных коммуникационных устройств. Мы говорим, что устройство связи – это устройство, которое будет иметь одну или несколько из следующих функций: совершать звонки, отправлять SMS или искать в Интернете.
# Пример:

```
class CallDevice:
    def call(self): raise NotImplementedError


class FileTransferDevice:
    def send_file(self): raise NotImplementedError


class InternetDevice:
    def send_file(self): raise NotImplementedError


class Smartphone(CallDevice, FileTransferDevice, InternetDevice):
    def call(self): ...
    def send_file(self): ...
    def browse_internet(self): ...


class Laptop(FileTransferDevice, InternetDevice):
    def send_file(self): ...
    def browse_internet(self): ...


class Phone(CallDevice):
    def call(self): ...
```
    
    
***
### Принцип инверсии зависимостей
Принцип инверсии зависимостей гласит:

* Модуль высокого уровня не должен зависеть от модулей низкого уровня. И то, и другое должно зависеть от абстракций. 

* Абстракции не должны зависеть от деталей реализации. Детали реализации должны зависеть от абстракций.

Если ваш код уже реализует принципы открытости/закрытости и подстановки Лисков, он уже будет неявно согласован с принципом инверсии зависимостей.  

Следуя принципу открытости/закрытости, вы создаете интерфейсы, которые можно использовать для предоставления различных высокоуровневых реализаций. Следуя принципу подстановки Лисков, вы гарантируете, что сможете заменить экземпляры класса низкого уровня объектами класса высокого уровня без какого-либо негативного воздействия на приложение. Таким образом, следуя этим двум принципам, вы гарантируете, что ваши классы высокого уровня и классы низкого уровня зависят от интерфейсов. Следовательно, вы неявно следуете принципу инверсии зависимостей.
# Пример:
```
class StorageClient(Storage):
	def __init__(self, storage: Storage):
		self.storage = storage

	def get_all(self):
		return self.storage.get_all()

	def get(self, *args):
		return self.storage.get(*args)

	def save(self, *args):
		return self.storage.save(*args)
   ```
        
  